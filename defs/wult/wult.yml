# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Definitions for wult CSV file.

WakeLatency:
    title: "C-state wake latency"
    descr: >-
        The time between the moment the delayed event was generated (launch time) till the moment
        the measured CPU started executing instructions after it woke up from a C-state. Note, the
        delayed event may be generated by many event sources, like an I210 network adapter or the
        TSC deadline timer. There may be subtleties related to that. For example, in the former
        case, the NIC sends an MSI message to the PCIe host at launch time. The PCIe link may be in
        a low power state (L-state), depending on whether PCIe ASPM is enabled. There may be
        multiple PCIe bridges between the NIC and the host. This pretty much depends on the platform
        configuration.
    type: "float"
    unit: "microsecond"
    short_unit: "us"
WakeLatencyRaw:
    title: "Raw (not adjusted) C-state wake latency"
    descr: >-
        Same as 'WakeLatency', but without the measurement overhead adjustments.
    type: "float"
    unit: "microsecond"
    short_unit: "us"
SilentTime:
    title: "Silent Time"
    descr: >-
        Time spent in a C-state before the the launch time (the moment the delayed event is
        generated). Or to put it differently, 'SilentTime' is time before idle minus launch time.
    type: "float"
    unit: "microsecond"
    short_unit: "us"
IntrLatency:
    title: "Interrupt latency"
    descr: >-
        The time between the moment the delayed event was generated (launch time) till the moment
        the interrupt handler of the delayed event was executed.
    type: "float"
    unit: "microsecond"
    short_unit: "us"
IntrLatencyRaw:
    title: "Raw (not adjusted) interrupt latency"
    descr: >-
        Same as 'IntrLatency', but without the measurement overhead adjustments.
    type: "float"
    unit: "microsecond"
    short_unit: "us"
IntrOff:
    title: "Interrupts disabled"
    descr: >-
        Status indicating whether or not interrupts were disabled during the test.
    type: "bool"
LDist:
    title: "Launch Distance"
    descr: >-
        How far in the future wult scheduled the event.
    type: "float"
    unit: "microsecond"
    short_unit: "us"
CPUFreq:
    title: "CPU frequency after wake up"
    descr: >-
        CPU frequency after wake up from the C-state is measured by taking APERF and MPERF counters
        in "after idle" and the interrupt handler. Therefore, this is an average CPU frequency for
        the period of time between TAI and TIntr.
    type: "float"
    unit: "megahertz"
    short_unit: "MHz"
ReqCState:
    title: "Requested C-State name"
    descr: >-
        The requested C-state name. This is the Linux CPU C-state name, do not confuse it with
        hardware C-state names.
    type: "str"
CC0%:
    title: "Busy percent"
    descr: >-
        Percent of the time spent in the C0 state during the idle period. Calculated as
        ('CC0Cyc' / 'TotCyc') * 100.
    type: "float"
    unit: "%"
    short_unit: "%"
CC1Derived%:
    title: "Derived C1 residency"
    descr: >-
        Percent of the time spent in core C1 state during the idle period. Calculated as
        ('TotCyc' - 'CC0Cyc' - 'sum(CC*Cyc)'') / 'TotCyc' * 100, where 'sum(CC*Cyc)' is a sum of all
        core C-state cycles. In other word, it is calculated from C0 cycles minus all non-C1 cycles.
    type: "float"
    unit: "%"
    short_unit: "%"
CCx%:
    title: "C{groups[0]} residency"
    descr: >-
        Percent of the time spent in core {groups[0]} C-state during the idle period. Calculated as
        ('C{groups[0]}Cyc' / 'TotCyc') * 100.
    type: "float"
    unit: "%"
    short_unit: "%"
    patterns:
      - 'C(C\d+)%'
    key_substitute: "C{GROUPS[0]}%"
MCx%:
    title: "M{groups[0]} residency"
    descr: >-
        Percent of the time spent in module {groups[0]} state during the idle period. Calculated
        as ('M{groups[0]}Cyc' / 'TotCyc') * 100.
    type: "float"
    unit: "%"
    short_unit: "%"
    patterns:
      - 'M(C\d+)%'
    key_substitute: "M{GROUPS[0]}%"
PCx%:
    title: "P{groups[0]} residency"
    descr: >-
        Percent of the time spent in package {groups[0]} state during the idle period. Calculated
        as ('P{groups[0]}Cyc' / 'TotCyc') * 100.
    type: "float"
    unit: "%"
    short_unit: "%"
    patterns:
      - 'P(C\d+)%'
    key_substitute: "P{GROUPS[0]}%"
SMICnt:
    title: "SMI count while measuring 'WakeLatency' or 'IntrLatency'"
    descr: >-
        How many system management interupts (SMI) happened while measuring 'WakeLatency' and
        'IntrLatency'.
    type: "int"
NMICnt:
    title: "NMI count while measuring 'WakeLatency' or 'IntrLatency'"
    descr: >-
        How many non-maskable interrupts (NMI) happened while measuring 'WakeLatency' and
        'IntrLatency'.
    type: "int"
SWIRQCnt:
    title: "Count of unrelated software interrupts"
    descr: >-
        How many unrelated software interrupts happened before the scheduled delayed event.
        Unrelated software interrupts increase the measured 'WakeLatency' and 'IntrLatency'.
    type: "int"
WarmupDelay:
    title: "The I210 NIC link warm up delay"
    descr: >-
        When the CPU wakes up from the C-state, wult first warms up the PCIe link(s) by reading the
        I210 NIC status register. This read will make sure the PCIe link(s) are ready for the time
        after idle read operation. For example, if the link(s) were in an L1 state due to ASPM, they
        will be woken up from this state. 'WarmupDelay' is the time it takes to read the I210 NIC
        status register. It is measured using TSC, and gets subtracted it from the "time after
        idle" timestamp that is read later. In other words, 'WakeLatency' does not include
        'WarmupDelay'.
    type: "float"
    unit: "microsecond"
    short_unit: "us"
LatchDelay:
    title: "The I210 NIC time latch delay"
    descr: >-
        When the CPU wakes up from the C-state, wult first reads the status register to warm up the
        link (see 'WarmupDelay'), and right after that it latches I210 NIC time by reading the
        "System Time Residue Register" ('SYSTIMR', 0xB6F8). 'LatchDelay' is the time it takes to
        read the 'SYSTIMR' register. It is measured using TSC. The I210 NIC latches the time when it
        sees the 'SYSTIMR' read operation. The assumption is that it will take half of the
        'LatchDelay' for the 'SYSTIMR' read request to propagate from the CPU to the I210 NIC.
        Therefore, half of 'LatchDelay' later gets subtracted from 'WakeLatency'.
    type: "float"
    unit: "microsecond"
    short_unit: "us"
